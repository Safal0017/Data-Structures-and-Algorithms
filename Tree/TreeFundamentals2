isTwoTreeIdentical: https://leetcode.com/problems/same-tree/

bool isSameTree(TreeNode* p, TreeNode* q) {

        if(!p && !q) return 1;
        if(!p || !q) return 0;
        
        if(p->val!=q->val) return 0;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);

    }

areTwoTreeMirror: https://www.geeksforgeeks.org/problems/two-mirror-trees/1

/* Given two trees, should return true if they are
   mirror of each other. */
class Solution {
    
    void MakeMirror(Node* root) {
        if(!root)
        return;
        
        swap(root->left, root->right);
        MakeMirror(root->left);
        MakeMirror(root->right);
    }
    
    bool isTreeIdentical(Node* p, Node* q) {

        if(!p && !q) return 1;
        if(!p || !q) return 0;
        
        if(p->data!=q->data) return 0;
        return isTreeIdentical(p->left, q->left) && isTreeIdentical(p->right, q->right);

    }
    
  public:
    bool areMirror(Node* a, Node* b) {
        // Your code here
        MakeMirror(a);
        return isTreeIdentical(a, b);
    }
};

isTreeBalanced: https://www.geeksforgeeks.org/problems/check-for-balanced-tree/1

O(n^2)
class Solution {
    
    int heightBT(Node* root) {
        if(!root)
        return 0;
        
        return 1+max(heightBT(root->left), heightBT(root->right));
    }
    
  public:
    bool isBalanced(Node* root) {
        // code here
        if(!root)
        return 1;
        
        int l = heightBT(root->left);
        int r = heightBT(root->right);
        
        if(abs(l-r)>1)
        return 0;
        else
        return isBalanced(root->left)&&isBalanced(root->right);
    }
};

Approach 2: 

O(n)

class Solution {
    
    int heightBT(Node* root, bool &valid) {
        if(!root)
        return 0;
        
        int l = heightBT(root->left, valid);
        int r=0;
        if(valid) {
            r = heightBT(root->right, valid);
            if(abs(l-r)>1)
            valid = 0;
        }
        return 1+max(l,r);
    }
    
  public:
    bool isBalanced(Node* root) {
        // code here
        //At any moment, left and right height difference gets > 1, valid = 0;
        bool valid = 1;
        heightBT(root, valid);
        return valid;
    }
};

//Check if the nodes are cousins in Binary Tree: https://leetcode.com/problems/cousins-in-binary-tree/description/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {

    void findLevel(TreeNode* root, int &l1, int &l2, int &x, int &y, int currL) {
        if(!root)
        return;

        if(root->val == x){
            l1 = currL;
        }
        if(root->val == y) {
            l2 = currL;
        }
        findLevel(root->left, l1, l2, x, y, currL+1);
        findLevel(root->right, l1, l2, x, y, currL+1);
    }

    void isSameParent(TreeNode* root, int &x, int &y, bool &isSameP) {
        if(!root)
        return;

        cout<<"Now At: "<<root->val<<endl;
        if(root->left && root->right) {
            if(root->left->val==x&&root->right->val==y || root->left->val==y&&root->right->val==x){
                isSameP = true;
                return;
            }
        }

        isSameParent(root->left, x, y, isSameP);
        if(!isSameP) {
            isSameParent(root->right, x, y, isSameP);
        }
    }

public:
    bool isCousins(TreeNode* root, int x, int y) {
        if(!root)
        return 0;
        int l1 = -1, l2 = -1;
        findLevel(root, l1, l2, x, y, 0);
        if(l1!=l2)
        return 0;

        cout<<l1<<" "<<l2<<endl;

        //check for if parents same
        bool isSameP = false;
        isSameParent(root, x, y, isSameP);
        return !isSameP;
    }
};
