/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

Link: https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/

class Solution {

    void findTarget(vector<char> &directions, int dist, int &height, bool &flag, TreeNode* root, int start) {
        if(!root)
        return;

        if(root->val == start) {
            height = max(height, dist);
            flag = true;
            return;
        }

        directions.push_back('L');
        findTarget(directions, dist+1, height, flag, root->left, start);
        
        if(flag) return;

        directions.pop_back();
        directions.push_back('R');

        findTarget(directions, dist+1, height, flag, root->right, start);
        if(flag) return;

        directions.pop_back();
    }

    void BTHeight(int &maxHeight, int height, vector<char> &directions, int index, TreeNode* root, TreeNode* blocker = nullptr) {

        if(!root || root == blocker)
        return;

        maxHeight = max(maxHeight, height);

    //     if(index >= 0 && index < directions.size()) {
    //     if(directions[index] == 'R') {
    //         BTHeight(maxHeight, height-1, directions, index+1, root->right);
    //         return;
    //     }
    //     if(directions[index] == 'L') {
    //         BTHeight(maxHeight, height-1, directions, index+1, root->left);
    //         return;
    //     }
    // }
    // BTHeight(maxHeight, height+1, directions, index+1, root->left);
    // BTHeight(maxHeight, height+1, directions, index+1, root->right);

    if (index >= 0 && index < directions.size()) {
        if (directions[index] == 'R') {
            BTHeight(maxHeight, height - 1, directions, index + 1, root->right, root);
            // Explore other side with blocker = right child to avoid going "back"
            BTHeight(maxHeight, height + 1, directions, index + 1, root->left, root->right);
        } else if (directions[index] == 'L') {
            BTHeight(maxHeight, height - 1, directions, index + 1, root->left, root);
            // Explore other side with blocker = left child
            BTHeight(maxHeight, height + 1, directions, index + 1, root->right, root->left);
        }
    } else {
        // Explore both directions freely
        BTHeight(maxHeight, height + 1, directions, index + 1, root->left, blocker);
        BTHeight(maxHeight, height + 1, directions, index + 1, root->right, blocker);
    }


    }

public:
    int amountOfTime(TreeNode* root, int start) {

        if(!root)
        return 0;
        vector<char> directions;
        int dist = 0;
        bool flag = false;
        int height = 0;
        findTarget(directions, dist, height, flag, root, start);
        cout<<height<<" "<<flag<<endl;
        for(int i=0;i<directions.size();i++){
            cout<<directions[i]<<" ";
        }
    
        int maxHeight = height;
        int index = 0;
        BTHeight(maxHeight, height, directions, index, root, nullptr);

        return maxHeight;
    }
};
