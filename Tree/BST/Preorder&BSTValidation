LINK:https://www.geeksforgeeks.org/problems/preorder-traversal-and-bst4006/1

// User function Template for C++

class Node {
public:
	int data;
	Node* left;
	Node* right;
	Node(int value) {
		data = value;
		left = right = NULL;
	}
};

class Solution {
    
    Node* PreorderBST(int arr[], int &index, int lower, int upper, int N) {
        if(index>=N || arr[index]<lower || arr[index]>upper)
        return NULL;
        
        Node* root = new Node(arr[index++]);
        root->left = PreorderBST(arr, index, lower, root->data, N);
        root->right = PreorderBST(arr, index, root->data, upper, N);
        return root;
    }
    
  public:
    int canRepresentBST(int arr[], int N) {
        // code here
        if(N == 0)
        return 1;
        
        //Approach 1
        //Using recursive stack, T.C: 0(N), S.C: 0(N)
        // int index = 0;
        // PreorderBST(arr, index, INT_MIN, INT_MAX, N);
        // return index==N;
        
        //Approach 2:
        //Using Iterative stack approach & STL for range check,
        //T.C: 0(N), S.C: 0(N)
        stack<int> lower;
        stack<int> upper;
        lower.push(INT_MIN);
        upper.push(INT_MAX);
        
        for(int i=0;i<N;i++) {
            
            //Out of range & ans not possible.
            if(arr[i]<lower.top())
            return 0; 
            
            //Out of range & pop until it satisfies the range
            while(arr[i]>upper.top()) {
                upper.pop();
                lower.pop();
            }
            
            //Within the range, and make changes to right & left range based on curr node
            int left = lower.top();
            int right = upper.top();
            lower.pop();
            upper.pop();
            lower.push(arr[i]);
            upper.push(right);
            lower.push(left);
            upper.push(arr[i]);
            
        }
        return 1;
        
    }
};
