Problem: 215. Kth Largest Element in an Array
Link: https://leetcode.com/problems/kth-largest-element-in-an-array/description/

Problem Statement:
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?

 

Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
 

Constraints:

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104

CODE:

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        // Kth Largest Element - 3 Approaches Analysis
        // ===============================================

        // Approach 1: Sort Array - O(n log n), O(1) space
        // 1. Sort entire array: O(n log n)
        // 2. Return arr[n-k]: O(1)
        // ✅ Simple but always processes ALL elements

        // Approach 2: MaxHeap (Extract k times) - O(n + k log n), O(1) space
        // 1. Build max-heap from array: O(n)
        // 2. Extract maximum k times: O(k log n)
        // ✅ Good when k ≈ n/2, worst case O(n log n)

        // Approach 3: MinHeap (Size k) - O(n log k), O(k) space ★ OPTIMAL
        // 1. Build min-heap with first k elements:
        //    - Step-down (heapify): O(k)
        //    - priority_queue.push(): O(k log k)  ← WE'LL USE THIS
        // 2. For remaining (n-k) elements:
        //    - If arr[i] > heap.top(): pop top, push arr[i]
        //    - Each operation, insertion & deletion: O(2 log k)
        // 3. Final heap.top() = kth largest
        // ✅ BEST when k << n (log k << log n)

        // Approach 4:
        // Using Quick Select
        //  Quickselect is closely related to Quicksort, but it’s optimized for
        //  finding the k-th largest (or smallest) element without fully sorting
        //  the array.
        
        //  Quicksort: Recursively partitions the array into two halves and
        //  sorts both sides. Quickselect: Uses the same partitioning step as
        //  Quicksort but only recurses into the side that contains the k-th
        //  element. This makes it faster on average — O(n) average time vs. O(n
        //  log n) for full sorting.


        // Key Insight:
        // kth largest → MinHeap(size k): eliminates smallest k+1 candidates
        // kth smallest → MaxHeap(size k): eliminates largest k+1 candidates

        // Complexity Comparison (k=4, n=1000):
        // Approach 1: O(1000 log 1000) = ~10K operations
        // Approach 2: O(1000 + 4 log 1000) = 1,012 operations ~ 1K operations
        // Approach 3: O(1000 log 4) = 602 operations << 1K ★ WINNER

        // Implementation: Using priority_queue (less code, same result)
        // We'll use Approach 3 for optimal performance

        priority_queue<int, vector<int>, greater<int>> p;

        for (int i = 0; i < k; i++)
            p.push(nums[i]);

        for (int i = k; i < nums.size(); i++) {
            if (nums[i] > p.top()) {
                p.pop();
                p.push(nums[i]);
            }
        }

        return p.top();
    }
};
