Link:
Leetcode: https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
GFG: https://www.geeksforgeeks.org/problems/merge-two-bst-s/1


Leetcode Code:

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {

    void inorder(TreeNode* root, vector<int> &ans) {

        if(!root)
        return;

        inorder(root->left, ans);
        ans.push_back(root->val);
        inorder(root->right, ans);

    }

public:
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {

        //Approach 1,
        //create a vector, inorder of bst1 + inorder of bst2
        //sort the final vector in nlogn, T.C: 0(nlogn), S.C: 0(n)

        //Approach 2,
        //create 2 vectors, optimizing T.C: 0(n);
        //the one below.

        //Approach 3,
        //Utilizing 4th way of inorder traversal, root & all left nodes into the stack,
        //while popping, compare from both the stacks and 
        //insert the smallest into the ans vector first

        vector<int> ans1;
        vector<int> ans2;
        vector<int> ans;

        inorder(root1, ans1);
        inorder(root2, ans2);

        int first = 0;
        int second = 0;

        while(first < ans1.size() && second < ans2.size()) {
            if(ans1[first] < ans2[second]){
                ans.push_back(ans1[first++]);
            }
            else {
                ans.push_back(ans2[second++]);
            }
        }

        while(first < ans1.size()) {
            ans.push_back(ans1[first++]);
        }

        while(second < ans2.size()) {
            ans.push_back(ans2[second++]);
        }

        return ans;
    }
};

GFG Code (Slight memory optimization for large inputs):
Code:

/*
class Node {
  public:
    int data;
    Node *left;
    Node *right;

    Node(int val) {
        data = val;
        left = right = NULL;
    }
};
*/

class Solution {
    
    void inorder(Node* root, vector<int> &ans) {

        if(!root)
        return;

        inorder(root->left, ans);
        ans.push_back(root->data);
        inorder(root->right, ans);

    }
    
  public:
    vector<int> merge(Node *root1, Node *root2) {
        // code here
        vector<int> ans;
        ans.reserve(100000);  // Pre-allocate for large inputs
        
        inorder(root1, ans);
        int n1 = ans.size();
        inorder(root2, ans);
        
        vector<int> ans2(ans.begin() + n1, ans.end());
        ans.resize(n1);
        
        vector<int> result(ans.size() + ans2.size());
        std::merge(ans.begin(), ans.end(), ans2.begin(), ans2.end(), result.begin());
        
        return result;
    }
};
