LINK:https://www.geeksforgeeks.org/problems/avl-tree-insertion/1


#include <iostream>
using namespace std;

class Node {
    public:
    int data, height;
    Node* left, *right;
    Node(int val) {
        data = val;
        height = 1;
        left = right = NULL;
    }
};

int getHeight(Node *root) {
    if(!root)
    return 0;
    
    return 1+max(getHeight(root->left), getHeight(root->right));
}

int getBalance(Node *root) {
    return getHeight(root->left)-getHeight(root->right);
}

Node* LeftRotate(Node* root) {
    
    Node* child = root->right;
    Node* leftChild = child->left;
    child->left = root;
    root->right = leftChild;
    
    //Update the height (root & then child)
    root->height = 1+max(getHeight(root->left), getHeight(root->right));
    child->height = 1+max(getHeight(child->left), getHeight(child->right));
    
    return child;
    
}

Node* RightRotate(Node* root) {
    
    Node* child = root->left;
    Node* rightChild = child->right;
    child->right = root;
    root->left = rightChild;
    
    //Update the height (root & then child)
    root->height = 1+max(getHeight(root->left), getHeight(root->right));
    child->height = 1+max(getHeight(child->left), getHeight(child->right));
    
    return child;
    
}

Node* insert(Node* root, int key) {
    
    //Doesn't Exist
    if(!root)
    return new Node(key);
    
    //Exist (Root)
    if(key<root->data) //LeftSide
    root->left = insert(root->left, key); 
    else if(key > root->data) //RightSide
    root->right = insert(root->right, key);
    else //Duplicate elements not allowed
    return root;
    
    //Update the height
    root->height = 1+max(getHeight(root->left), getHeight(root->right));
    
    //Get the balance
    int balance = getBalance(root);
    
    //LL (balance > 1 && key < root->left->data) -> RightRotate(topE)
    //LR (balance > 1 && key > root->left->data) -> LeftRotate(midE)+RightRotate(topE)
    //RR (balance < -1 && key > root->left->data) -> LeftRotate(topE)
    //RL (balance < -1 && key < root->left->data) -> RightRotate(midE)+LeftRotate(topE)
    
    if(balance > 1 && key < root->left->data) { //LL
        return RightRotate(root);
    } else if(balance > 1 && key > root->left->data) { //LR
        root->left = LeftRotate(root->left);
        return RightRotate(root);
    } else if(balance < -1 && key > root->right->data) { //RR
        return LeftRotate(root);
    } else if(balance < -1 && key < root->right->data) { //RL
        root->right = RightRotate(root->right);
        return LeftRotate(root);
    } else { // Already Balanced    
        return root;
    }
    
}

void preOrder(Node* root) {
    if(!root)
    return;
    
    cout<<root->data<<" ";
    preOrder(root->left);
    preOrder(root->right);
}

void inOrder(Node* root) {
    if(!root)
    return;
    
    inOrder(root->left);
    cout<<root->data<<" ";
    inOrder(root->right);
}

int main()
{
    
    Node* root = NULL;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 30);
    root = insert(root, 50);
    root = insert(root, 70);
    root = insert(root, 5);
    root = insert(root, 100);
    root = insert(root, 95);
    
    cout<<"PreOrder: "<<endl;
    preOrder(root);
    cout<<endl;
    cout<<"InOrder: "<<endl;
    inOrder(root);

    return 0;
}

//Expected Output
// PreOrder: 
// 20 10 5 50 30 95 70 100 
// InOrder: 
// 5 10 20 30 50 70 95 100
