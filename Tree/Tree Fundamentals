#include <iostream>
#include<vector>
#include<queue>
using namespace std;

class Node {
public:
	int data;
	Node* left;
	Node* right;
	Node(int value) {
		data = value;
		left = right = NULL;
	}
};

void TreeBFSPrint(Node* root) {
	queue<Node*> q;
	Node* temp;
	q.push(root);
	while(!q.empty()) {
		temp = q.front();
		q.pop();
		if(temp->data)
			cout<<temp->data<<" ";

		if(temp->left)
			q.push(temp->left);
		if(temp->right)
			q.push(temp->right);
	}

};

void PreOrderTreeTraversal(Node* root) {
	if(!root)
		return;

	cout<<root->data<<" ";
	PreOrderTreeTraversal(root->left);
	PreOrderTreeTraversal(root->right);
}

void InOrderTreeTraversal(Node* root) {
	if(!root)
		return;

    InOrderTreeTraversal(root->left);
	cout<<root->data<<" ";
	InOrderTreeTraversal(root->right);
}

void PostOrderTreeTraversal(Node* root) {
	if(!root)
		return;

	PostOrderTreeTraversal(root->left);
	PostOrderTreeTraversal(root->right);
	cout<<root->data<<" ";
}

Node* NodeCreation(int rootV) {
	if(!rootV)
		return NULL;

	Node* temp = new Node(rootV);
	int x;

	cout<<"Enter the left child of "<<temp->data<<" :";
	cin>>x;
	if(x>0) {
		temp->left = NodeCreation(x);
	}

	cout<<"Enter the right child of "<<temp->data<<" :";
	cin>>x;
	if(x>0) {
		temp->right = NodeCreation(x);
	}
	return temp;

}

// int SizeOfBT(Node* root){
//     if(!root)
//     return 0;
    
//     return 1+SizeOfBT(root->left)+SizeOfBT(root->right);
// }

void SizeOfBT(Node* root, int &count) {
    if(!root)
    return;
    
    count++;
    SizeOfBT(root->left, count);
    SizeOfBT(root->right, count);
}

int SumOfBT(Node* root){
    if(!root)
    return 0;
    
    return root->data+SumOfBT(root->left)+SumOfBT(root->right);
}

int CountLeafNodes(Node* root) {
    if(!root->left && !root->right)
    return 1;
    
    if(!root)
    return 0;
    
    return CountLeafNodes(root->left)+CountLeafNodes(root->right);
}

int CountNonLeafNodes(Node* root) {
    if(!root->left && !root->right)
    return 0;
    
    if(!root)
    return 0;
    
    return 1+CountNonLeafNodes(root->left)+CountNonLeafNodes(root->right);
}

int HeightOfBT(Node* root) {
    if(!root)
    return 0;
    
    return 1+ max(HeightOfBT(root->left), HeightOfBT(root->right));
}


int main()
{
	int x;
	cout<<"Enter the root Node value: "<<endl;
	cin>>x;
	// Node* root = new Node(x);
	// queue<Node*> q;
	// q.push(root);

	// Node* temp;
	// while(!q.empty()) {
	//     temp = q.front();
	//     q.pop();
	//     cout<<"Enter the left child of "<<temp->data<<" :"<<endl;
	//     cin>>x;
	//     if(x>0) {
	//         temp->left = new Node(x);
	//         q.push(temp->left);
	//     }
	//     cout<<"Enter the right child of "<<temp->data<<" :"<<endl;
	//     cin>>x;
	//     if(x>0) {
	//         temp->right = new Node(x);
	//         q.push(temp->right);
	//     }
	// }
	Node* root = NodeCreation(x);
	cout<<"Level Order Traversal: ";
	TreeBFSPrint(root);
	cout<<endl;
	cout<<"Pre Order Traversal: ";
	PreOrderTreeTraversal(root);
	cout<<endl;
	cout<<"In Order Traversal: ";
	InOrderTreeTraversal(root);
	cout<<endl;
	cout<<"Post Order Traversal: ";
	PostOrderTreeTraversal(root);
	cout<<endl;
	int count = 0;
	SizeOfBT(root, count);
	cout<<"Size of BT: "<<count<<endl;
	
	cout<<"Sum of BT: "<<SumOfBT(root)<<endl;
	cout<<"Count Leaf Nodes: "<<CountLeafNodes(root)<<endl;
	cout<<"Count NonLeaf Nodes: "<<CountNonLeafNodes(root)<<endl;
	cout<<"Height Of BT: "<<HeightOfBT(root)<<endl;

	return 0;
}

//SAMPLE OUTPUT:
// Enter the root Node value: 
// 1
// Enter the left child of 1 :2
// Enter the left child of 2 :4
// Enter the left child of 4 :-1
// Enter the right child of 4 :-1
// Enter the right child of 2 :5
// Enter the left child of 5 :-1
// Enter the right child of 5 :-1
// Enter the right child of 1 :3
// Enter the left child of 3 :-1
// Enter the right child of 3 :-1
// Level Order Traversal: 1 2 3 4 5 
// Pre Order Traversal: 1 2 4 5 3 
// In Order Traversal: 4 2 5 1 3 
// Post Order Traversal: 4 5 2 3 1 
// Size of BT: 5
// Sum of BT: 15
// Count Leaf Nodes: 3
// Count NonLeaf Nodes: 2
// Height Of BT: 3
