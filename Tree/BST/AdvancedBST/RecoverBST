Recover BST/Fixing two Nodes in a BST
Link:
Leetcode: https://leetcode.com/problems/recover-binary-search-tree/
GFG: https://www.geeksforgeeks.org/problems/fixed-two-nodes-of-a-bst/1

Code:

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        // Approach 1
        // inorder
        //+ sort
        //+ inorder(to make changes to corresponding nodes).

        // For all other approaches, we will be using 2 variables,
        // Initializing first = -1, second = -1.
        // if 1st time violation, update first & second.
        // when 2nd time violation, only update second.

        // Approach 2: Recursive Inorder (Recursive Stack 0(N))
        // Approach 3: Iteratvie Approach (Stack STL 0(N))
        // Approach 3: Stack & all left Elements (Stack STL 0(N))
        // Approach 4: Optimized S.C using Morris Traversal.
        // T.C: 0(N), S.C: 0(1)

        TreeNode* curr = NULL;
        TreeNode *first = NULL, *second = NULL;
        TreeNode *last = NULL, *present = NULL;

        while (root) {

            // left doesn't exist
            if (!root->left) {
                last = present;
                present = root;
                if (last && last->val > present->val) {
                    if (!first) {
                        first = last;
                    }
                    second = present;
                }
                root = root->right;
            }

            // left exist
            else {
                // Yet to explore
                curr = root->left;
                while (curr->right && curr->right != root) {
                    curr = curr->right;
                }
                //if curr is leaf node, then create a cycle.
                if (!curr->right) {
                    curr->right = root;
                    root = root->left;
                }
                // Already traversed
                else { // curr->right == root, so break the loop, check and move
                       // to the right
                    curr->right = NULL;
                    last = present;
                    present = root;
                    if (last && last->val > present->val) {
                        if (!first) {
                            first = last;
                        }
                        second = present;
                    }
                    root = root->right;
                }
            }
        }//while loop finished

        //Swap first & second's node->data to correct their position.
        int num = first->val;
        first->val = second->val;
        second->val = num;

    }
};
