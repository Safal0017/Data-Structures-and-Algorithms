Link: https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */

class Box {
public:
    bool BST;
    int sum;
    int min, max;
    Box(int data) {
        BST = 1;
        sum = data;
        min = data;
        max = data;
    }
};

class Solution {

    Box* find(TreeNode* root, int& totalSum) {
        // Leaf Nodes
        // Only LeftSide Exist
        // Only RightSide Exist
        // Both Sides Exists

        // Leaf Nodes
        if (!root->left && !root->right) {
            totalSum = max(totalSum, root->val);
            return new Box(root->val);
        }

        // Only LeftSide Exist
        else if (!root->right && root->left) {
            Box* head = find(root->left, totalSum);
            // leftside BST
            if (head->BST && head->max < root->val) {
                head->sum+=root->val;
                head->max = root->val;
                totalSum = max(totalSum, head->sum);
                return head;
            }
            // leftSide Not BST
            else {
                head->BST = 0;
                return head;
            }
        }

        // Only RightSide Exist
        else if (!root->left && root->right) {
            Box* head = find(root->right, totalSum);
            // leftside BST
            if (head->BST && head->min > root->val) {
                head->sum+=root->val;
                head->min = root->val;
                totalSum = max(totalSum, head->sum);
                return head;
            }
            // leftSide Not BST
            else {
                head->BST = 0;
                return head;
            }
        }

        // Both Sides Exists
        else {

            Box* LeftHead = find(root->left, totalSum);
            Box* RightHead = find(root->right, totalSum);

            // Both BST

            if (LeftHead->BST && RightHead->BST && LeftHead->max < root->val &&
                RightHead->min > root->val) {
                Box* head = new Box(root->val);
                head->sum += LeftHead->sum + RightHead->sum;
                head->min = LeftHead->min;
                head->max = RightHead->max;
                totalSum = max(totalSum, head->sum);
                return head;
            }
            // Not BST
            else {
                LeftHead->BST = 0;
                return LeftHead;
            }
        }
    }

public:
    int maxSumBST(TreeNode* root) {
        int totalSum = 0;
        find(root, totalSum);
        return totalSum;
    }
};
