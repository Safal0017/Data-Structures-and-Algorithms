To calculate LeftMost and RightMost Pos

#include <iostream>
#include<vector>
#include <queue>
using namespace std;

struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(const vector<int>& arr) {
	if (arr.empty() || arr[0] == -1) return nullptr;

	TreeNode* root = new TreeNode(arr[0]);
	queue<TreeNode*> q;
	q.push(root);

	int i = 1;
	while (!q.empty() && i < arr.size()) {
		TreeNode* current = q.front();
		q.pop();

		// Left child
		if (i < arr.size() && arr[i] != -1) {
			current->left = new TreeNode(arr[i]);
			q.push(current->left);
		}
		i++;

		// Right child
		if (i < arr.size() && arr[i] != -1) {
			current->right = new TreeNode(arr[i]);
			q.push(current->right);
		}
		i++;
	}
	return root;
}

void calculateLAndR(int &l, int &r, TreeNode* root, int pos) {
    if(!root)
    return;
    
    if(pos<l)
    l = pos;
    
    if(pos>r)
    r = pos;
    
    calculateLAndR(l, r, root->left, pos-1);
    calculateLAndR(l, r, root->right, pos+1);
}

int main()
{
	vector<int> arr = {1,2,3,4,5,-1,6,7,8,-1,-1,9,10,11,-1,-1,-1,12,-1,13,-1};
    TreeNode* root = buildTree(arr);
	int l=0,r=0;
	calculateLAndR(l,r,root, 0);
	
	cout<<l<<" "<<r;

	return 0;
}
