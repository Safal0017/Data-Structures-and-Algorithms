Problem: Find the index of the first occurrence in a string
LINK: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=problem-list-v2&envId=string-matching

Problem Statement: Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

 

Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.
 

Constraints:

1 <= haystack.length, needle.length <= 104
haystack and needle consist of only lowercase English characters.

CODE: (2 Approaches)

class Solution {
public:

    void findlps(vector<int> &lps, string &s) {
        int pre = 0, suff = 1;
        while(suff<s.size()) {
            if(s[pre] == s[suff]) {
                lps[suff] = pre+1;
                suff++,pre++;
            } else {
                if(pre == 0)
                {
                    lps[suff] = 0;
                    suff++;
                } else {
                    pre = lps[pre-1];
                }
            }
        }
    }

    int strStr(string haystack, string needle) {
        //Brute-force Approach 0(n^2)
        // int m = haystack.size();
        // int n = needle.size();

        // for(int i=0;i<=m-n;i++) {
        //     int first = i, second = 0;
        //     while(first < haystack.size() && second < needle.size()) {
        //         if(haystack[first] != needle[second])
        //         break;

        //         first++, second++;
        //     }
        //     if(second == needle.size())
        //     return first-second;
        // }

        // return -1;

        //KMP Algorithm 0(n)
        int m = haystack.size();
        int n = needle.size();
        vector<int> lps(n, 0);
        findlps(lps, needle);
        int first = 0, second = 0;

        while(first < m && second < n) {
            if(haystack[first] == needle[second])
            first++,second++;

            else {
                if(second == 0)
                first++;
                else 
                second = lps[second-1];
            }
        }

        if(second == needle.size())
        return first-second;
        else
        return -1;
        
    }
};
